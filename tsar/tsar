#!/usr/bin/env python
"""
this script is the executable and shell interface, calling the MainLoop() with an App object that contains various Screen objects from tsar 
"""
import sys

import urwid
import tsar
from tsar.app import App
from importlib import import_module
from os import listdir
import os
from whoosh import fields
from whoosh import index
from whoosh.qparser import QueryParser
from whoosh.qparser import MultifieldParser
from whoosh.qparser import OperatorsPlugin
from whoosh.searching import Results
from collections import OrderedDict
import contextlib
# from pprint import pprint
import time

# from app import App
from search_screen import SearchScreen
from select_screen import SelectScreen

def main(input_name):
    # specify project paths and name from user:
    # return configuration parameters (globals), search objects:
    (params, search_index, parser) = handle_user_input(input_name)

    search_screen = SearchScreen()
    select_screen = SelectScreen()

    kwargs = {'search_index': search_index, 'parser': parser, 'params': params, 'screen_list': [search_screen, select_screen]}

    app = App(**kwargs)
    urwid.MainLoop(app, palette=params.PALETTE).run()
    # with contextlib.closing(app) as app:
        # urwid.MainLoop(app, palette=params.PALETTE).run()

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def add_tutorial_records(search_index):
    """
    - adds tutorial records.
    """
    from datetime import datetime
    import time


    def tstamp():
        time.sleep(.001)
        return datetime.now()

    records = [dict(timestamp=tstamp(),
                    name='Welcome to tsar!  Press RETURN and select "content" to get started...',
                    content='Tsar (the Textual Storage And Retrieval utility) is a productivity tool somewhere between a snippet manager and a digital extension of your memory.  It is designed to obtain stored text records *as quickly as possible*.  \n\nTo this end, tsar currently has search-as-you-type document query powered by the Whoosh search engine; future versions will also have sorting, filtering, and record association functionality.  Additional features will include: copy to clipboard, import/search of existing files or folders, syntax highlighting, and much more.\n\nSome suggested usecases:\n- a searchable journal/diary\n- a snippet manager for code\n- as a repository of code examples or problem-solution pairs\n- anything else stored as records where fast retrieval of previously stored information is a priority.\n\nTo call tsar from terminal:\n- `$tsar` opens the default database (currently this one, but customizable).  `$tsar db_name` will open a database in `./index_files` corresponding to `./config_files/db_name_config.py`.\n\nPress ENTER to return to the search list and read the records that outline the basic useage of tsar.',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 1: Navigation and key commands',
                    content='RETURN: toggle between "search" and "record details" pages\nUP/DOWN: select different records (search page) or select different record fields (selected record page)\nESC: exit A*\nctrl u: edit current record/save record \nctrl x: cancel edits without saving \nctrl n: create a new record\n\n',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 2: Searching records',
                    content='From the search page, enter a query string to live-search matching results in the database.  By default, wildcards "?" and "*" are used for single/multi-character completion.  Also, common "stop" words (at, the, for, etc) are excluded from matching records.  The search syntax is powered by by Whoosh, and can be extensively customized for each database via the database_config.py file.  See the readme and Whoosh documentation (https://whoosh.readthedocs.io/en/latest/) for more details.',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 3: Search query examples',
                    content='Add rules to the search herrre ofr',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 4: Editing records',
                    content='press CTRL+U to edit (Update) fields in an existing record if they\'re editable; press CTRL+U again to save edits, or CTRL+X to cancel edits and leave the original record unaffected.',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 5: Creating a record',
                    content='CTRL+N: add a New record.  When you are finished, CTRL+U to Update the record or CTRL+X to cancel.',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 6: Deleting a record',
                    content='Warning: this action cannot currently be undone! Press CTRL+D to Delete a record.  Undo is not yet implemented.',
                    tags='tutorial'),
               dict(timestamp=tstamp(),
                    name='record 7: Managing databases',
                    content='Create a new database:\n\n1: Copy the "default_config.py" file to "new_database_config.py".  It can be edited to change the fields, search functionality, and more.\n\n2: From terminal, create a new search index with: tsar new_database, and follow the prompts.  The name of the config file will determine the "command argument" to acess it from the command line.',
                   tags='introduction'),
                dict(timestamp=tstamp(),
                    name='record 8: Feedback',
                    content="""This project is in beta.  If you have a bug report, feature request, or other feedback, please submit it through the GitHub project page.

-.......+s:........................................................--:/-::-/:-/
........hd+......................................................--------------
.........-.....................................................................
........-s.............................................omh.......-.............
......../d.............................................:o+........:---......---
........yN:............................................./........-/.:.:-.../---
........................................................y-.......:-.-..:.../...
........................................................m+.......:-....:.../...
......+.o.//:..........................................:hs.........::-.:.../.::
.....+/:d.ssh-.......................................................-/-.../:..
....++.ho.yd+d...................................................:-..../..-:...
...o/.oN-.dN-hh......................................+.s.o./.....-.....:-./....
.:y:.oNo.:NN::Ny....................................y:-h.s/-o.-..--....-:-:....
oy-.yNy..hMN:.sNs-...............................-:ds.sy./d.-y:/...-:--:-/./.::
:./mNy..oNMN-.-NNo-/...........................--oNy.-Ns.-Ns.-do/+....//--:/:..
/dMm/..sNMMd...mMN/-s/.......................//+mNo..hMo..dNs..hd/++-../..:-...
yh/../mMMMm:..-NMMm..yd/..................-oo/hNm:..oMM/..sMNs..sNh:+s:--./....
-../dMMMMh-...+MMMMo..sNd:............../yy-oNMh...+NMN-../MMNo..+NNo-oy/-:....
./dMMMMNo.....dMMMMm...yMNo...........:dd:.sNMh...:NMMN....NMMN:../NMd--yh:--:-
sNMMMMm/.....sMMMMMN-..-NMNy.-.......oNh..oNMN-...dMMMm....hMMMd...oNMd-.oNo...
yMMMMd-...../NMMMMMm....hMMMs.s-....oNd..-NMMs...:NMMMd....sMMMN:...dMMy..oNy..
yMMMh......:NMMMMMNo....yMMMN--d-...mN+..+MMN:...+MMMMy....+MMMM+...oMMN-..dN/.
yMNy......-mMMMMMMh.....dMMMM/.yh../MN-..yMMN....oMMMMy..../NMMMs...:MMM/..oMy.
yNy.......dMMMMMMd.....:NMMMN-./N:.+MN...hMMN....oMMMMy..../NMMMo.../MMM/..+My.
yy.......dMMMMMMm-.....hMMMN+..:Mo./MN-..yMMN-.../MMMMh..../MMMM/...oMMN-..sMs.
o.......dMMMMMMd-.....sMMMNo...+Mo..mMo..:NMM+...-NMMMm....+MMMN....dMMh...mN-.
-......dMMMMMNy......sMMMN+....dN/..+NN-..yMMm....hMMMN-...oMMMo...+NMN-..sMs.-
.....-dMMMMMm+.....-hMMMd-....hMd....+Nd-..hMMy...:NMMM+...yMMd...-mMN/..sNs...
....-mMMMMNs......oNMMm+....:dMm:/-...:hm/..yNNo...oNMMh...mMd-...dMm/.-hm/-...
...:mMMMNy-.....+mMMNs.....sNNy.:y/...../s/../ys:...+yys...ss....+ys-.:s/...:-.
..:mmmms-.....+dmmms-....omdo-...o.......::-::-:--:--:--:--:--:-::-::-:....../-
---.--.-..-..-..-.--.--.-........m:......::-::-::-::::-::-::-::-:-::-::....../-
--------------------------......:o/......--:--:--:----:--:--:--:-:--:--....../-
-.----------.-------------................-:..:..:..:-.-:..:..:..:-.--......./:
 -----------------`    .--:::::---`    .----:::::::-.`     `-----------..`     
  osssssssssssssss/   `:ossssss+.       osssssssssssssss-    -+ssssssssssss-   
  mMN:`-NMMMN-`/MMy  sNMMy:.-sMMMh.     mMm.My.`-mMMMN``   -dMMm/.```:dMMMM/   
  +o+   dMMMd  `oo/ sMMMd     -///-     :/:`M/   yMMMN    `NMMM+      .MMMM/   
        hMMMd       hMMMd                  `M/   yMMMN    .MMMM+      .MMMM/   
        hMMMd       :MMMN`                 `M/   yMMMN     yMMMy`     +MMMM/   
        hMMMd        .yNMNhssss+-          `M/   yMMMN      /dNMNhhhhmMMMMM/   
        hMMMd           `----/dMMN+        `M/   yMMMN        -NMMMy``-MMMM/   
        hMMMd                 .MMMM+       `M:   yMMMN       .mMMMh   .MMMM/   
        hMMMd       -:::.     .MMMMs       om`   yMMMN      `dMMMd`   .MMMM/   
        hMMMd       +MMMd`    +MMMm.    -hd.     yMMMN      hMMMm`    .MMMM/   
        hMMMd        :hNMNhyymMNd+`  +ssdMNssssshMMMMMss.  sMMMm.     .MMMM/   
        `````           ```````      dMN`````````````/MM/  `````       `````   
                                     dMN             :MM+                      
                                     ```             `--`                      


    """, tags='introduction')]
    sys.stdout.write('adding example records...')
    writer = search_index.writer()
    for record in records:
        writer.add_document(**record)
        time.sleep(.001)
    writer.commit()

def add_random_records(search_index, N):
    import random
    from datetime import datetime
    records = [dict(timestamp=datetime.now(),
                    name='record no {}'.format(j),
                    content='random.random()',
                    tags='tutorial') for j in range(N)]
    sys.stdout.write('adding example records...')
    writer = search_index.writer()
    for record in records:
        writer.add_document(**record)
        time.sleep(.001)
    writer.commit()

def handle_user_input(input_name):
    """
    tsar test requires:
        - tsar_path/config_files/test_config.py
        - tsar_path/index_files/index_files/test
    
    cmd_args[1] is string matched against index and config files.
    
    - try to open index -> set index_exists
    - try to read params -> set config_exists 

    - if input matches index, config: 
        return (config_path, index_path)
    
    - if only index file is missing: 
        - prompt to create new index: if yes,
        return (config_path, index_path)

    - if only config file is missing:
        - sys.exit('no config file found; unable to load tsar')

    - if neither config nor index exist:
        - show available others, or
        - prompt to create new from default
    """
    tsar_path = tsar.__file__.replace('__init__.py', '')
    index_folder = tsar_path + 'index_files/'
    config_folder = tsar_path + 'config_files/'

    while True:
        #handle 4 cases (config_exists, index_exists) -> {TT, FT, TF, FF}

        try:
            params = import_module('.config_files.{}_config'.format(input_name), 'tsar')
            config_exists = True
        except:
            config_exists = False

        try:
            search_index = index.open_dir(index_folder + input_name)
            parser = QueryParser(params.SEARCH_DISPLAY_FIELD, schema=search_index.schema)        
            index_exists = True
        except:
            index_exists = False

        if config_exists and index_exists:
            return (params, search_index, parser)

        if not config_exists and index_exists:
            sys.exit('error: index exists, but no config file found.')

        if config_exists and not index_exists:

            while True:
                clear_screen()
                user_resp = input('No index file found for {}_config.py.\n\nCreate a new one (return) or quit (q):'.format(config_folder + input_name))

                if user_resp.lower() == 'q':
                    clear_screen()
                    sys.exit()

                if user_resp == '':
                    clear_screen()
                    print('creating new index at:\n{}'.format(index_folder + input_name))
                    # time.sleep(2)
                    schema = fields.Schema(**params.SCHEMA_FIELDS)
                    if not os.path.exists(index_folder + input_name):
                        os.mkdir(index_folder + input_name)
                        search_index = index.create_in(index_folder + input_name, schema)
                        parser = QueryParser(params.SEARCH_DISPLAY_FIELD, schema=search_index.schema)
                        if input_name == 'default':
                            add_tutorial_records(search_index=search_index)  
                            # add_random_records(search_index=search_index, N=80)
                    return (params, search_index, parser)

        if not (config_exists or index_exists):
            # show user existing files, prompt to open new
            # allow user to create a new from default config

            config_files = ['{}'.format(f) for f in listdir(config_folder) if f.endswith('_config.py')]
            config_names = [f.replace('_config.py', '') for f in config_files]

            while input_name not in config_names:
                clear_screen()
                print('Enter existing tsar config name or quit (q):\n'.format(config_folder))
                print(*['\r{}\n'.format(j) for j in config_names])
                input_name = input()

                if input_name.lower() == 'q':
                    clear_screen()
                    sys.exit()


if __name__ == '__main__':

    cmd_args = sys.argv
    try:
        input_name = cmd_args[1]
    except IndexError:
        input_name = 'default'

    main(input_name)
